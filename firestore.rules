rules_version = '2';

// IrriTrack Firestore Security Rules
// Deploy via: firebase deploy --only firestore:rules
//
// Current auth model: App uses local auth (not Firebase Auth yet)
// These rules validate data structure and allowed values to prevent
// malformed writes. Reads are open since there's no Firebase Auth.
// TODO: When Firebase Auth is integrated, add request.auth checks.

service cloud.firestore {
  match /databases/{database}/documents {

    // ============ USERS ============
    match /users/{email} {
      allow read: if true;
      allow write: if request.resource.data.keys().hasAll(['password', 'role', 'name'])
        && request.resource.data.role in ['manager', 'technician']
        && request.resource.data.name is string;
    }

    // ============ PROPERTIES ============
    match /properties/{propertyId} {
      allow read: if true;
      allow write: if request.resource.data.keys().hasAll(['address'])
        && request.resource.data.address is string;
    }

    // ============ INSPECTIONS ============
    match /inspections/{inspectionId} {
      allow read: if true;
      allow write: if request.resource.data.keys().hasAll(['property_id', 'status', 'date'])
        && request.resource.data.status in ['assigned', 'in_progress', 'review', 'quote_sent', 'completed'];
    }

    // ============ QUOTES ============
    match /quotes/{quoteId} {
      allow read: if true;
      allow write: if request.resource.data.keys().hasAll(['status', 'access_token'])
        && request.resource.data.status in ['draft', 'sent', 'viewed', 'approved', 'rejected', 'expired'];
    }

    // ============ REPAIR TASKS ============
    match /repair_tasks/{taskId} {
      allow read: if true;
      allow write: if request.resource.data.keys().hasAll(['status'])
        && request.resource.data.status in ['pending', 'assigned', 'in_progress', 'completed'];
    }

    // ============ COMPANY SETTINGS ============
    match /settings/{docId} {
      allow read: if true;
      allow write: if request.resource.data.keys().hasAll(['company_name'])
        && request.resource.data.company_name is string;
    }

    // ============ METADATA (ID counters) ============
    match /metadata/{docId} {
      allow read: if true;
      allow write: if true;
    }

    // ============ PASSWORD RESET REQUESTS ============
    match /password_reset_requests/{email} {
      allow read: if true;
      allow write: if request.resource.data.keys().hasAll(['status'])
        && request.resource.data.status in ['pending', 'approved', 'denied'];
    }

    // Deny everything else by default (no wildcard match)
  }
}
